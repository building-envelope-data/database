schema {
  query: Query
  mutation: Mutation
}

interface Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  componentId: UUID!
  createdAt: DateTime!
  creatorId: UUID!
  description: String
  locale: Locale!
  name: String
  resourceTree: GetHttpsResourceTree!
  resources: [GetHttpsResource!]!
  timestamp: DateTime!
  uuid: UUID!
  warnings: [String!]!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

type AppliedMethod {
  arguments: [NamedMethodArgument!]!
  methodId: UUID!
  sources: [NamedMethodSource!]!
}

type CielabColor {
  aStar: Float!
  bStar: Float!
  lStar: Float!
}

type CreateGetHttpsResourceError {
  code: CreateGetHttpsResourceErrorCode!
  message: String!
  path: [String!]!
}

type CreateGetHttpsResourcePayload {
  errors: [CreateGetHttpsResourceError!]
  getHttpsResource: GetHttpsResource
  query: Query!
}

type CreateOpticalDataError {
  code: CreateOpticalDataErrorCode!
  message: String!
  path: [String!]!
}

type CreateOpticalDataPayload {
  errors: [CreateOpticalDataError!]
  opticalData: OpticalData
  query: Query!
}

type CrossDatabaseDataReference {
  dataId: UUID!
  dataKind: DataKind!
  dataTimestamp: DateTime!
  databaseId: UUID!
}

type DataApproval {
  approverId: UUID!
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  timestamp: DateTime!
}

type FileMetaInformation {
  dataFormatId: UUID!
  path: [String!]!
}

type GetHttpsResource implements Node {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethod
  archivedFilesMetaInformation: [FileMetaInformation!]!
  children: [GetHttpsResource!]!
  data: OpticalData!
  dataFormatId: UUID!
  description: String!
  hashValue: String!
  id: ID!
  locator: URL!
  parent: GetHttpsResource
  uuid: UUID!
}

"A connection to a list of items."
type GetHttpsResourceConnection {
  "A list of edges."
  edges: [GetHttpsResourceEdge!]
  "A flattened list of the nodes."
  nodes: [GetHttpsResource!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type GetHttpsResourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GetHttpsResource!
}

type GetHttpsResourceTree {
  nonRootVertices: [GetHttpsResourceTreeNonRootVertex!]!
  root: GetHttpsResourceTreeRoot!
}

type GetHttpsResourceTreeNonRootVertex {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethod!
  parentId: ID!
  value: GetHttpsResource!
  vertexId: ID!
}

type GetHttpsResourceTreeRoot {
  value: GetHttpsResource!
  vertexId: ID!
}

type Mutation {
  createGetHttpsResource(input: CreateGetHttpsResourceInput!): CreateGetHttpsResourcePayload!
  createOpticalData(input: CreateOpticalDataInput!): CreateOpticalDataPayload!
}

type NamedMethodArgument {
  name: String!
  value: Any!
}

type NamedMethodSource {
  name: String!
  value: CrossDatabaseDataReference!
}

type OpenEndedDateTimeRange {
  from: DateTime
  until: DateTime
}

type OpticalData implements Node & Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  cielabColors: [CielabColor!]!
  colorRenderingIndices: [Float!]!
  componentId: UUID!
  createdAt: DateTime!
  creatorId: UUID!
  description: String
  id: ID!
  infraredEmittances: [Float!]!
  locale: Locale!
  name: String
  nearnormalHemisphericalSolarReflectances: [Float!]!
  nearnormalHemisphericalSolarTransmittances: [Float!]!
  nearnormalHemisphericalVisibleReflectances: [Float!]!
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
  resourceTree: GetHttpsResourceTree!
  resources: [GetHttpsResource!]!
  timestamp: DateTime!
  uuid: UUID!
  warnings: [String!]!
}

"A connection to a list of items."
type OpticalDataConnection {
  "A list of edges."
  edges: [OpticalDataEdge!]
  "A flattened list of the nodes."
  nodes: [OpticalData!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type OpticalDataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpticalData!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type Query {
  allOpticalData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [OpticalDataSortInput!] timestamp: DateTime where: OpticalDataPropositionInput): OpticalDataConnection
  getHttpsResource(id: UUID!): GetHttpsResource
  getHttpsResources("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GetHttpsResourceSortInput!] where: GetHttpsResourcePropositionInput): GetHttpsResourceConnection
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  opticalData(id: UUID! locale: Locale timestamp: DateTime): OpticalData
}

type ToTreeVertexAppliedConversionMethod {
  arguments: [NamedMethodArgument!]!
  methodId: UUID!
  sourceName: String!
}

input AppliedMethodInput {
  arguments: [NamedMethodArgumentInput!]!
  methodId: UUID!
  sources: [NamedMethodSourceInput!]!
}

input AppliedMethodPropositionInput {
  and: [AppliedMethodPropositionInput!]
  or: [AppliedMethodPropositionInput!]
  methodId: UuidPropositionInput
  arguments: ListNamedMethodArgumentFilterTypePropositionInput
  sources: ListFilterInputTypeOfNamedMethodSourcePropositionInput
}

input AppliedMethodSortInput {
  methodId: SortEnumType
}

input CielabColorInput {
  aStar: Float!
  bStar: Float!
  lStar: Float!
}

input CielabColorPropositionInput {
  and: [CielabColorPropositionInput!]
  or: [CielabColorPropositionInput!]
  lStar: FloatPropositionInput
  aStar: FloatPropositionInput
  bStar: FloatPropositionInput
}

input CreateGetHttpsResourceInput {
  accessToken: String!
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodInput
  archivedFilesMetaInformation: [FileMetaInformationInput!]!
  dataFormatId: UUID!
  dataId: UUID!
  description: String!
  hashValue: String!
  parentId: UUID
}

input CreateOpticalDataInput {
  accessToken: String!
  appliedMethod: AppliedMethodInput!
  approvals: [DataApprovalInput!]!
  cielabColors: [CielabColorInput!]!
  colorRenderingIndices: [Float!]!
  componentId: UUID!
  createdAt: DateTime!
  creatorId: UUID!
  description: String
  infraredEmittances: [Float!]!
  locale: String!
  name: String
  nearnormalHemisphericalSolarReflectances: [Float!]!
  nearnormalHemisphericalSolarTransmittances: [Float!]!
  nearnormalHemisphericalVisibleReflectances: [Float!]!
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
  rootResource: RootGetHttpsResourceInput!
  warnings: [String!]!
}

input CrossDatabaseDataReferenceInput {
  dataId: UUID!
  dataKind: DataKind!
  dataTimestamp: DateTime!
  databaseId: UUID!
}

input CrossDatabaseDataReferencePropositionInput {
  and: [CrossDatabaseDataReferencePropositionInput!]
  or: [CrossDatabaseDataReferencePropositionInput!]
  dataId: UuidPropositionInput
  dataTimestamp: DateTimePropositionInput
  dataKind: DataKindPropositionInput
  databaseId: UuidPropositionInput
}

input DataApprovalInput {
  approverId: UUID!
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  timestamp: DateTime!
}

input DataApprovalPropositionInput {
  and: [DataApprovalPropositionInput!]
  or: [DataApprovalPropositionInput!]
  timestamp: DateTimePropositionInput
  signature: StringPropositionInput
  keyFingerprint: StringPropositionInput
  query: StringPropositionInput
  response: StringPropositionInput
  approverId: UuidPropositionInput
}

input DataKindPropositionInput {
  equalTo: DataKind
  notEqualTo: DataKind
  in: [DataKind!]
  notIn: [DataKind!]
}

input DataXSortInput {
  locale: SortEnumType
  componentId: SortEnumType
  name: SortEnumType
  description: SortEnumType
  creatorId: SortEnumType
  createdAt: SortEnumType
  appliedMethod: AppliedMethodSortInput
  id: SortEnumType
  xmin: SortEnumType
}

input DateTimePropositionInput {
  equalTo: DateTime
  notEqualTo: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  greaterThan: DateTime
  notGreaterThan: DateTime
  greaterThanOrEqualTo: DateTime
  notGreaterThanOrEqualTo: DateTime
  lessThan: DateTime
  notLessThanOrEqualTo: DateTime
}

input FileMetaInformationInput {
  dataFormatId: UUID!
  path: [String!]!
}

input FileMetaInformationPropositionInput {
  and: [FileMetaInformationPropositionInput!]
  or: [FileMetaInformationPropositionInput!]
  path: StringsPropositionInput
  dataFormatId: UuidPropositionInput
}

input FloatPropositionInput {
  equalTo: Float
  notEqualTo: Float
  in: [Float!]
  notIn: [Float!]
  greaterThan: Float
  notGreaterThan: Float
  greaterThanOrEqualTo: Float
  notGreaterThanOrEqualTo: Float
  lessThan: Float
  notLessThanOrEqualTo: Float
}

input FloatsPropositionInput {
  all: FloatPropositionInput
  none: FloatPropositionInput
  some: FloatPropositionInput
  any: Boolean
}

input GetHttpsResourcePropositionInput {
  and: [GetHttpsResourcePropositionInput!]
  or: [GetHttpsResourcePropositionInput!]
  id: UuidPropositionInput
  description: StringPropositionInput
  hashValue: StringPropositionInput
  dataFormatId: UuidPropositionInput
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodPropositionInput
  archivedFilesMetaInformation: ListFilterInputTypeOfFileMetaInformationPropositionInput
  dataId: UuidPropositionInput
  parentId: NullableOfUuidPropositionInput
  parent: GetHttpsResourcePropositionInput
}

input GetHttpsResourceSortInput {
  description: SortEnumType
  hashValue: SortEnumType
  dataFormatId: SortEnumType
  dataId: SortEnumType
  data: DataXSortInput
  parentId: SortEnumType
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodSortInput
  parent: GetHttpsResourceSortInput
  id: SortEnumType
  xmin: SortEnumType
}

input ListFilterInputTypeOfCielabColorPropositionInput {
  all: CielabColorPropositionInput
  none: CielabColorPropositionInput
  some: CielabColorPropositionInput
  any: Boolean
}

input ListFilterInputTypeOfDataApprovalPropositionInput {
  all: DataApprovalPropositionInput
  none: DataApprovalPropositionInput
  some: DataApprovalPropositionInput
  any: Boolean
}

input ListFilterInputTypeOfFileMetaInformationPropositionInput {
  all: FileMetaInformationPropositionInput
  none: FileMetaInformationPropositionInput
  some: FileMetaInformationPropositionInput
  any: Boolean
}

input ListFilterInputTypeOfNamedMethodSourcePropositionInput {
  all: NamedMethodSourcePropositionInput
  none: NamedMethodSourcePropositionInput
  some: NamedMethodSourcePropositionInput
  any: Boolean
}

input ListGetHttpsResourceFilterTypePropositionInput {
  all: GetHttpsResourcePropositionInput
  none: GetHttpsResourcePropositionInput
  some: GetHttpsResourcePropositionInput
  any: Boolean
}

input ListNamedMethodArgumentFilterTypePropositionInput {
  all: NamedMethodArgumentPropositionInput
  none: NamedMethodArgumentPropositionInput
  some: NamedMethodArgumentPropositionInput
  any: Boolean
}

input NamedMethodArgumentInput {
  name: String!
}

input NamedMethodArgumentPropositionInput {
  and: [NamedMethodArgumentPropositionInput!]
  or: [NamedMethodArgumentPropositionInput!]
  name: StringPropositionInput
}

input NamedMethodSourceInput {
  name: String!
  value: CrossDatabaseDataReferenceInput!
}

input NamedMethodSourcePropositionInput {
  and: [NamedMethodSourcePropositionInput!]
  or: [NamedMethodSourcePropositionInput!]
  name: StringPropositionInput
  value: CrossDatabaseDataReferencePropositionInput
}

input NullableOfUuidPropositionInput {
  equalTo: UUID
  notEqualTo: UUID
  in: [UUID]
  notIn: [UUID]
  greaterThan: UUID
  notGreaterThan: UUID
  greaterThanOrEqualTo: UUID
  notGreaterThanOrEqualTo: UUID
  lessThan: UUID
  notLessThanOrEqualTo: UUID
}

input OpticalDataPropositionInput {
  and: [OpticalDataPropositionInput!]
  or: [OpticalDataPropositionInput!]
  id: UuidPropositionInput
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
  nearnormalHemisphericalSolarReflectances: FloatsPropositionInput
  nearnormalHemisphericalSolarTransmittances: FloatsPropositionInput
  nearnormalHemisphericalVisibleReflectances: FloatsPropositionInput
  nearnormalHemisphericalVisibleTransmittances: FloatsPropositionInput
  infraredEmittances: FloatsPropositionInput
  colorRenderingIndices: FloatsPropositionInput
  cielabColors: ListFilterInputTypeOfCielabColorPropositionInput
}

input OpticalDataSortInput {
  locale: SortEnumType
  componentId: SortEnumType
  name: SortEnumType
  description: SortEnumType
  creatorId: SortEnumType
  createdAt: SortEnumType
  appliedMethod: AppliedMethodSortInput
  id: SortEnumType
  xmin: SortEnumType
}

input RootGetHttpsResourceInput {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodInput
  archivedFilesMetaInformation: [FileMetaInformationInput!]!
  dataFormatId: UUID!
  description: String!
  hashValue: String!
}

input StringPropositionInput {
  and: [StringPropositionInput!]
  or: [StringPropositionInput!]
  equalTo: String
  notEqualTo: String
  contains: String
  doesNotContain: String
  in: [String]
  notIn: [String]
  startsWith: String
  doesNotStartWith: String
  endsWith: String
  doesNotEndWith: String
}

input StringsPropositionInput {
  all: StringPropositionInput
  none: StringPropositionInput
  some: StringPropositionInput
  any: Boolean
}

input ToTreeVertexAppliedConversionMethodInput {
  arguments: [NamedMethodArgumentInput!]!
  methodId: UUID!
  sourceName: String!
}

input ToTreeVertexAppliedConversionMethodPropositionInput {
  and: [ToTreeVertexAppliedConversionMethodPropositionInput!]
  or: [ToTreeVertexAppliedConversionMethodPropositionInput!]
  methodId: UuidPropositionInput
  arguments: ListNamedMethodArgumentFilterTypePropositionInput
  sourceName: StringPropositionInput
}

input ToTreeVertexAppliedConversionMethodSortInput {
  methodId: SortEnumType
  sourceName: SortEnumType
}

input UuidPropositionInput {
  equalTo: UUID
  notEqualTo: UUID
  in: [UUID!]
  notIn: [UUID!]
  greaterThan: UUID
  notGreaterThan: UUID
  greaterThanOrEqualTo: UUID
  notGreaterThanOrEqualTo: UUID
  lessThan: UUID
  notLessThanOrEqualTo: UUID
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum CreateGetHttpsResourceErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum CreateOpticalDataErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum DataKind {
  CALORIMETRIC_DATA
  HYGROTHERMAL_DATA
  OPTICAL_DATA
  PHOTOVOLTAIC_DATA
}

enum SortEnumType {
  ASC
  DESC
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("Streamed when true." if: Boolean "The initial elements that shall be send down to the consumer." initialCount: Int! "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String) on FIELD

scalar Any

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"BCP 47 compliant Language Tag string"
scalar Locale

scalar URL @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc3986")

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")